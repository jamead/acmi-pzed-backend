= Address Space Tutorial
ifndef::imagesdir[:imagesdir: ../images]


This tutorial expands the basic tutorial by introducing a module into a project that comes with its own address space definition. `example_desyrdl` module will be used to show how FWK and DesyRDL gets used together. `example_desyrdl` module is developed at MSK-DESY to show capabilities of DesyRDL.


== Adding example_desyrdl into the project

After completing the Basic Tutorial, change directory into `./fwk` and recursively initialize the submodules. This step is necessary to get other required tools sources (eg. DesyRDL)

[source,shell]
----
cd fwk
git submodule update --init --recursive
----

Then, prepare a Python Virtual Environment `env`. This can be achieved by running the makefile from the project (`demo`) root directory. The below command, among performing several configuration tasks, fetches and installs other needed python packages.

[source,shell]
----
cd ..
make env
----

Next step is to clone the `example_desyrdl` into the project sources folder (`./src`)

[source,shell]
----
git clone git@gitlab.desy.de:fpgafw/mod/test/example_desyrdl.git src/example_desyrdl
----


Just like in the basic tutorial, add the `main.tcl` file of `example_desyrdl` into `tcl/project.tcl`

* open tcl/project.tcl
* edit the `init{}` procedure as follows

[source,tcl,title=./tcl/project.tcl]
----
proc init {} {
  addSrcModule app ${::fwfwk::ProjectPath}/src/app_demo/tcl/main.tcl
  addSrcModule example_desyrdl ${::fwfwk::ProjectPath}/src/example_desyrdl/tcl/main.tcl
----

== Inspecting the example_desyrdl module's address space

We can see how example_desyrdl module's address space looks like by opening its SystemRDL file

[source,c,title=./src/example_desyrdl/rdl/example_desyrdl.rdl]
----
`include "example_desyrdl.vh" //automatically created and added by fwk with conf variables such a C_VERSION ...

/* default values of defined variables */
`ifndef C_ID
`define C_ID 0x1FF00002
`endif
`ifndef C_VERSION
`define C_VERSION 0x00000000
`endif

/*
 module a address space
 */
addrmap example_desyrdl {
  name = "example DesyRDL address space";
  desyrdl_interface = "AXI4L";

  reg {
    desc="Module Identification Number";
    default sw = r;
    default hw = r;
    field {} data[32] = `C_ID;
  } ID @0x00;

  reg {
    desc="Module Version Number";
    default sw = r;
    default hw = r;
    field {} changes [8] =  `C_VERSION & 0x000000FF;
    field {} patch [8]   = (`C_VERSION & 0x0000FF00) >> 8;
    field {} minor [8]   = (`C_VERSION & 0x00FF0000) >> 16;
    field {} major [8]   = (`C_VERSION & 0xFF000000) >> 24;
  } VERSION @0x04;

  reg {
    desc = "scratch register, only SW can write, default value 0xA at address 0x10";
    default sw = rw;
    default hw = r;
    default swacc;
    default swmod;
    field {} data[32] = 0x0000000A;
  } SCRATCH @0x10;

  reg {
    desc = "test register, SW and HW can write, we flag needed to trigger write from hw";
    default sw = rw;
    default hw = rw;
    default we = true;
    default swacc;
    default swmod;
    field {} data[32] = 0x0000000B;
  } TEST ;

  reg {
    desc = "2D test register, only SW can write, HW reads";
    default sw = rw;
    default hw = r;
    field {} data[32] = 0x0000001B;
  } TABLE [12] ;

  reg {
    desc = "2D test register, only HW can write, SW can read, external register";
    default sw = r;
    default hw = w;
    field {} data[32] ;
  } CLK_FREQ [4] ;

  reg COEF { // definition of register with no instantiation, type only, fixed type: 1.1.16
    desc = "coeffitients";
    default sw = rw;
    default hw = r;
    desyrdl_data_type = "fixed16"; // by default all are uint, types: int, uint, fixed<#>, ufixed<#>, float
    field {} coef[18] ;
  };

  COEF SSP_A[2][2]; // instantiate 3D 2x2 table of coefficients
  SSP_A->desc = "3D resiters with fixed point coefficients";

  reg INFO { //define type of register and instantiate the same time 2D table
    default sw = rw;
    default hw = r;
    field {} data[32];
  } INFO[2] ;

  INFO INFO_NEW[4]; // new 4D table of INFO register
  INFO_NEW.data->reset = 32'd10; // change default value of data filed of INFO register type

  external mem { // memory, always external for HW implementation
    desc = "Test memory 1";
    memwidth = 32;
    mementries = 64;
  } MEM_TEST1;

  external mem {
    desc = "Test memory 2";
    memwidth = 18;
    mementries = 128;
    desyrdl_data_type = "fixed16";
  } MEM_TEST2;

};
----

This address space starts by including a Verilog Header file called ```example_desyrdl.vh```. This file gets automatically generated by FWK when module gets introduced to FWK's address space. Through this file, users can influence the properties of registers from the project configuration. This section will be described on later stages on the tutorial.

We also see `C_ID` and `C_VERSION` registers defined on a fixed addresses. This is a culture in MSK-DESY to always attach identification and git version information to the beginning of the module address space. These registers are important for higher level software to verify that it is working with the correct version and configuration of the module. As can be seen in code, they are using the Verilog macros coming from the `example_desyrdl.vh` (`C_VERSION` and `C_ID`)

Pay attention to the line `desyrdl_interface = "AXI4L";`. This line tells the DesyRDL to generate AXI4-Lite interface for the module ie. Address Decoder will have AXI4-Lite interface. Users can comment that out if custom decoder will be used.

== Adding example_desyrdl address space into FWK

If we create the project once again with `make project cfg=default` and view it with `make gui cfg=default`, we'll see that example_desyrdl module gets added to the project, however some files under the hood are missing. This is because we have not told FWK to generate and add the necessary address space related files into the project.

This can be achieved setting the `::fwfwk::addr::TypesToGen` and `::fwfwk::addr::TypesToAdd` variables on the `init{}` procedure of `project.tcl`

[source,tcl,title=./tcl/project.tcl]
----
  set ::fwfwk::addr::TypesToGen {vhdl map}
  set ::fwfwk::addr::TypesToAdd {vhdl}
----

We are telling FWK to generate VHDL and map files and add only the VHDL files into the project.

Next step is to add the `example_desyrdl` register space into the project main address space. This is done by editing the `setAddressSpace` procedure on `project.tcl`

[source,tcl,title=./tcl/project.tcl]
----
proc setAddressSpace {} {
  addAddressSpace ::fwfwk::AddressSpace "example_desyrdl" ARRAY {C0 0x00800000 8M} example_desyrdl::AddressSpace
}
----

Here we are simply adding the example_desyrdl type into the `::fwfwk::AddressSpace` instance. `C0` indicates that this is Access Channel 0. There is also a arbitary offset that we introduce (0x00800000) with a 8 MB of range.


== Viewing the generated VHDL

Now we can re-create the project once again and see that FWK has added the necessary files which was used inside the `example_desyrdl_top` entity. We see a axi4-lite decoder as well as each register showing up as a separate VHDL entity.

image::desyrdl_generated_files.png[]

== Conclusion

We have now added two different modules into a project and saw how FWK generates necessary HDL files out from SystemRDL files. For more in depth information please visit the main documentation page. Next tutorial will show more complex setup with real BSP layer.
